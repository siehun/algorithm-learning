

### 二叉树

#### 二叉树的前中后序遍历

似乎没有什么技术含量

```
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}
```

```

class Solution {
    public void inorder(TreeNode root,List<Integer> list){
        if(root==null){return;}
        inorder(root.left,list);
        list.add(root.val);
        inorder(root.right,list);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<>();
        inorder(root,list);
        return list;

    }
}
```

```

class Solution {
    public void postorder(TreeNode root,List<Integer> list){
        if(root==null){
            return;
        }
        postorder(root.left,list);
        postorder(root.right,list);
        list.add(root.val);
    }
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<>();
        postorder(root,list);
        return list;

    }
}
```



#### 判断两个树的结构是否相同

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public static boolean isSameTree(TreeNode p,TreeNode q){
        if(p==null^q==null){//一个为空，一个不为空
            return false;
        }
        if(p==null&&q==null){
            return true;
        }
        return p.val==q.val&&isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
```

#### 镜面树

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public static boolean isSymmetric(TreeNode root){
        return isMirror(root,root);
    }
    public static boolean isMirror(TreeNode h1, TreeNode h2){
        if(h1==null^h2==null){
            return false;
        }
        if(h1==null&&h2==null){
            return true;
        }
        return h1.val==h2.val&&isMirror(h1.left,h2.right)&&isMirror(h2.left,h1.right);
    }
```

#### 返回一个树的最大深度

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public static int maxDepth(TreeNode root){
        if(root==null){
            return 0;
        }
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
```

#### 给出一个树的先序和中序遍历，建树

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int val){
            this.val=val;
        }
    }
    public static TreeNode buildTree(int[] pre,int[] in){
        if(pre==null||in==null||pre.length!=in.length){
            return null;
        }
        return f(pre,0,pre.length-1,in,0,in.length-1);
    }
    public static TreeNode f(int[] pre,int L1,int R1,int[] in,int L2,int R2){
        if(L1>R1){
            return null;
        }
        TreeNode head=new TreeNode(pre[L1]);
        if(L1==R1){
            return head;
        }
        int find=L2;
        while(in[find]!=pre[L1]){
            find++;
        }
        head.left=f(pre,L1+1,L1+find-L2,in,L2,find-1);
        head.right=f(pre,L1+find-L2+1,R1,in,find+1,R2);
        return head;
    }
```

优化

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int val){
            this.val=val;
        }
    }
    public static TreeNode buildTree(int[] pre, int[] in){
        if(pre==null||in==null||pre.length!=in.length){
            return null;
        }
        HashMap<Integer,Integer> valueIndexMap=new HashMap<>();
        for(int i=0;i<in.length;i++){
            valueIndexMap.put(in[i],i);
        }
        return f(pre,0,pre.length-1,in,0,in.length-1,valueIndexMap);
    }
    public static TreeNode f(int[] pre, int L1, int R1, int[] in, int L2, int R2,HashMap<Integer,Integer> valueIndexMap){
        if(L1>R1){
            return null;
        }
        TreeNode head=new TreeNode(pre[L1]);
        if(L1==R1){
            return head;
        }
        int find=valueIndexMap.get(pre[L1]);
        head.left=f(pre,L1+1,L1+find-L2,in,L2,find-1,valueIndexMap);
        head.right=f(pre,L1+find-L2+1,R1,in,find+1,R2,valueIndexMap);
        return head;
    }
```

#### 依次返回一个树每层的节点

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public List<List<Integer>> levelOrderBottom(TreeNode root){
        List<List<Integer>> ans=new LinkedList<>();
        if(root==null){
            return ans;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> curAns = new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode curNode = queue.poll();
                curAns.add(curNode.val);
                if (curNode.left != null) {
                    queue.add(curNode.left);
                }
                if (curNode.right != null) {
                    queue.add(curNode.right);
                }
            }
            ans.add(0, curAns);
        }
        return ans;
    }
    public static void main(String[] args){
        int testTime=10000;
        long start;
        long end;
        System.out.println("======");
        ArrayList<Integer> arr1=new ArrayList<>();
        start=System.currentTimeMillis();
        for(int i=0;i<testTime;i++){
            arr1.add(0,i);
        }
        end=System.currentTimeMillis();
        System.out.println(end-start);
        LinkedList<Integer> arr2=new LinkedList<>();
        start=System.currentTimeMillis();
        for(int i=0;i<testTime;i++){
            arr2.add(0,i);
        }
        end=System.currentTimeMillis();
        System.out.println(end-start);
    }
```

#### 是否为平衡树

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public static boolean isBalanced(TreeNode root){
        return process(root).isBalanced;
    }
    public static class Info{
        public boolean isBalanced;
        public int height;
        public Info(boolean i,int h){
            isBalanced=i;
            h=height;
        }
    }
    public static Info process(TreeNode x){
        if(x==null){
            return new Info(true,0);
        }
        Info leftInfo=process(x.left);
        Info rightInfo=process(x.right);
        int height=Math.max(leftInfo.height,rightInfo.height)+1;
        boolean isBalanced=leftInfo.isBalanced&& rightInfo.isBalanced&&Math.abs(leftInfo.height- rightInfo.height)<2;
        return new Info(isBalanced,height);
    }
```

#### 是否为搜索树

```
    public static class TreeNode{
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int value){
            val=value;
        }
    }
    public static class Info{
        public int max;
        public int min;
        public boolean isBST;
        public Info(boolean is,int ma,int mi){
            isBST=is;
            max=ma;
            min=mi;
        }
    }
    public static boolean ans(TreeNode root){
        return process(root).isBST;
    }
    public static Info process(TreeNode x){
        if(x==null){
            return null;
        }
        Info leftInfo=process(x.left);
        Info rightInfo=process(x.right);
        int max=x.val;
        int min=x.val;
        if(x.left!=null){
            max=Math.max(leftInfo.max,max);
            min=Math.min(leftInfo.min,min);
        }
        if(x.right!=null){
            max=Math.max(rightInfo.max,max);
            min=Math.min(rightInfo.min,min);
        }
        boolean isBST=true;
        if(leftInfo!=null&&!leftInfo.isBST){
           isBST=false; 
        }
        if(rightInfo!=null&&!rightInfo.isBST){
            isBST=false;
        }
        boolean leftMaxLessX=leftInfo==null?true:(leftInfo.max<x.val);
        boolean rightMinMoreX=rightInfo==null?true:(rightInfo.min>x.val);
        if(!leftMaxLessX||!rightMinMoreX){
            isBST=false;
        }
        return new Info(isBST,max,min);
    }
```

#### 是否组成路径和

