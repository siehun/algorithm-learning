## 堆

#### 覆盖最多的线段个数

```
    public static class Line{//开始和结尾
        public int start;
        public int end;
        public Line(int st,int ed){
            start=st;
            end=ed;
        }
    }
    public static class StartCompartor implements Comparator<Line>{//比较器，按开始比较
        @Override
        public int compare(Line o1,Line o2){
            return o1.start-o2.start;
        }
    }
    public static int maxCover2(int[][] m){
        Line[] lines=new Line [m.length];
        for(int i=0;i<m.length;i++){
            lines[i]=new Line(m[i][0],m[i][1]);
        }
        Arrays.sort(lines,new StartCompartor());//数组按开始位置排序
        PriorityQueue<Integer> heap=new PriorityQueue<>();//定义一个小根堆
        int max=0;//定义覆盖数的最大值
        for(int i=0;i<lines.length;i++){
            while(!heap.isEmpty()&&heap.peek()<=lines[i].start){//如果堆不为空，并且堆顶元素比加入元素的开始要小
                heap.poll();//弹出
            }
            heap.add(lines[i].end);//把结尾加入
            max=Math.max(max,heap.size());//更新max值
        }
        return max;
    }
```

```
    public static int maxCover1(int[][] lines){
        int min=Integer.MAX_VALUE;
        int max=Integer.MIN_VALUE;
        for(int i=0;i<lines.length;i++){
            min=Math.min(min,lines[i][0]);
            max=Math.max(max,lines[i][1]);
        }
        int cover=0;
        for(double p=min+0.5;p<max;p+=1){
            int cur=0;
            for(int i=0;i<lines.length;i++){
                if(lines[i][0]<p&&lines[i][1]>p){
                    cur++;
                }
            }
            cover=Math.max(cover,cur);
        }
        return cover;
    }
```

#### 前缀树

```
    public static class Node1{//节点包含三个信息，pass表示经过数，end表示结尾数，nexts表示以下的路径数
        public int pass;
        public int end;
        public Node1[] nexts;
        public Node1(){
            pass=0;
            end=0;
            nexts=new Node1[26];//a-z26个英文字母，以非空来表示节点存在
        }
    }
    public static class Trie1{
        private Node1 root;//Trie树一开始只需要搞一个root节点就行
        public Trie1(){
            root=new Node1();
        }
        public void insert(String word){
            if(word==null){
                return;
            }
            char[] str=word.toCharArray();
            Node1 node=root;
            node.pass++;
            int path=0;
            for(int i=0;i<str.length;i++){
                path=str[i]-'a';
                if(node.nexts[path]==null){//如果没有节点就搞一个节点出来
                    node.nexts[path]=new Node1();
                }
                node=node.nexts[path];//跳一下，path++
                node.pass++;
            }
            node.end++;//最后end++
        }
        public void delete(String word){
            if(search(word)!=0){
                char[] chs=word.toCharArray();
                Node1 node =root;
                node.pass--;
                int path=0;
                for(int i=0;i<chs.length;i++){
                    path=chs[i]-'a';
                    if(--node.nexts[path].pass==0){
                    //如果发现当前位置的pass减减后为0，之间将当前位置的next[path]置空
                        node.nexts[path]=null;
                        return;
                    }
                    node=node.nexts[path];
                }
                node.end--;
            }
        }
        public int prefixNumber(String pre){//好像跟search一模一样
            if(pre==null){
                return 0;
            }
            char[] chs=pre.toCharArray();
            Node1 node=root;
            int index=0;
            for(int i=0;i<chs.length;i++){
                index=chs[i]-'a';
                if(node.nexts[index]==null){
                    return 0;
                }
                node=node.nexts[index];
            }
            return node.pass;
        }
        public int search (String word){
            if(word==null){
                return 0;
            }
            char[] chs=word.toCharArray();//把字符串搞成字符数组形式
            Node1 node=root;
            int index=0;
            for(int i=0;i<chs.length;i++){//从头节点出发顺着往下查
                index=chs[i]-'a';
                if(node.nexts[index]==null){//如果不存在节点，那么之间返回，否则跳下一个
                    return 0;
                }
                node=node.nexts[index];
            }
            return node.end;//跳到终点之间返回
            
        }

    }
```

#### 链表排序

小的在前，等于的在中间，大于的在后边

```
    public static class Node{
        public int val;
        public Node next;
        public Node(int value){
            val=value;
        }
    }
    public static Node listPartition2(Node head,int pivot){
        Node sH=null;
        Node sT=null;
        Node eH=null;
        Node eT=null;
        Node mH=null;
        Node mT=null;
        Node next=null;
        while(head!=null){
            next=head.next;
            head.next=null;
            if(head.val<pivot){
                if(sH==null){
                    sH=head;
                    sT=head;
                }
                else{
                    sT.next=head;
                    sT=head;
                }
            }
            else if(head.val==pivot){
                if(eH==null){
                    eH=head;
                    eT=head;
                }
                else{
                    eH.next=head;
                    eH=head;
                }
            }
            else{
                if(mH==null){
                    mH=head;
                    mT=head;
                }
                else{
                    mT.next=head;
                    mT=head;
                }
            }
            head=next;
        }
        if(sT!=null){
            sT.next=eH;
            eT=eT==null?sT:eT;
        }
        if(eT!=null){
            eT.next=mH;
        }
        return sH!=null ?sH:(eH!=null?eH:mH);
    }
```

#### 桶排序

```
    public static void radixSort(int[] arr){
        if(arr==null||arr.length<2){
            return;
        }
        radixsort(arr,0,arr.length-1,maxbits(arr));
    }
    public static int maxbits(int[] arr){
        int max=Integer.MIN_VALUE;
        for(int i=0;i<arr.length;i++){
            max=Math.max(max,arr[i]);
        }
        int res=0;
        while(max!=0){
            res++;
            max/=10;
        }
        return res;
    }
    public static int getDigit(int num,int d){
        int ans=0;
        while(d--!=0){
           ans=num%10;
           num/=10;
        }
        return ans;

    }
    public static void radixsort(int[] arr,int L,int R,int digit){
        final int radix=10;
        int i=0;int j=0;
        int[] help=new int[R-L+1];
        for(int d=1;d<=digit;d++){
            int[] count=new int[radix];
            for( i=L;i<=R;i++){
                j=getDigit(arr[i],d);
                count[j]++;
            }
            for(i=1;i<radix;i++){
                count[i]=count[i]+count[i-1];
            }
            for(i=R;i>=L;i--){
                j=getDigit(arr[i],d);
                help[count[j]-1]=arr[i];
                count[j]--;
            }
            for(i=L,j=0;i<=R;i++,j++){
                arr[i]=help[i];
            }
        }
    }
```

#### 先中后序的非递归遍历

```
    public static class Node{
        public int val;
        public Node left;
        public Node right;
        public Node(int value){
            val=value;
        }
    }
    public static void in(Node cur){
        System.out.println("in-order");
        if(cur!=null){
            Stack<Node> stack=new Stack<>();
            while(!stack.empty()||cur!=null){
                if(cur!=null){
                    stack.push(cur);
                    cur=cur.left;
                }
                else{
                    cur=stack.pop();
                    System.out.print(cur.val+" ");
                    cur=cur.right;
                }
            }
        }
        System.out.println();
    }
    public static void pos1(Node head){
        System.out.println("pos_order");
        if(head!=null){
            Stack<Node> s1=new Stack<>();
            Stack<Node> s2=new Stack<>();
            s1.push(head);
            while(!s1.empty()){
                head=s1.pop();
                s2.push(head);
                if(head.left!=null){
                    s1.push(head.left);
                }
                if(head.right!=null){
                    s1.push(head.right);
                }
            }
            while(!s2.empty()){
                System.out.println(s2.pop().val);
            }
        }
        System.out.println();
    }
    public static void pre(Node head){
        System.out.println("pre_order");
        if(head!=null){
            Stack<Node> stack=new Stack<>();
            stack.add(head);
            while(!stack.empty()){
                head=stack.pop();
                System.out.println(head.val+" ");
                if(head.right!=null){
                    stack.push(head.right);
                }
                if(head.left!=null){
                    stack.push(head.left);
                }
            }
        }
        System.out.println();
    }
```

#### 堆的改写

```
public class HeapGreater<T> {

	private ArrayList<T> heap;
	private HashMap<T, Integer> indexMap;
	private int heapSize;
	private Comparator<? super T> comp;

	public HeapGreater(Comparator<? super T> c) {
		heap = new ArrayList<>();
		indexMap = new HashMap<>();
		heapSize = 0;
		comp = c;
	}

	public boolean isEmpty() {
		return heapSize == 0;
	}

	public int size() {
		return heapSize;
	}

	public boolean contains(T obj) {
		return indexMap.containsKey(obj);
	}

	public T peek() {
		return heap.get(0);
	}

	public void push(T obj) {
		heap.add(obj);
		indexMap.put(obj, heapSize);
		heapInsert(heapSize++);
	}

	public T pop() {
		T ans = heap.get(0);
		swap(0, heapSize - 1);
		indexMap.remove(ans);
		heap.remove(--heapSize);
		heapify(0);
		return ans;
	}

	public void remove(T obj) {
		T replace = heap.get(heapSize - 1);
		int index = indexMap.get(obj);
		indexMap.remove(obj);
		heap.remove(--heapSize);
		if (obj != replace) {
			heap.set(index, replace);
			indexMap.put(replace, index);
			resign(replace);
		}
	}

	public void resign(T obj) {
		heapInsert(indexMap.get(obj));
		heapify(indexMap.get(obj));
	}

	// 请返回堆上的所有元素
	public List<T> getAllElements() {
		List<T> ans = new ArrayList<>();
		for (T c : heap) {
			ans.add(c);
		}
		return ans;
	}

	private void heapInsert(int index) {
		while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index) {
		int left = index * 2 + 1;
		while (left < heapSize) {
			int best = left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
			best = comp.compare(heap.get(best), heap.get(index)) < 0 ? best : index;
			if (best == index) {
				break;
			}
			swap(best, index);
			index = best;
			left = index * 2 + 1;
		}
	}

	private void swap(int i, int j) {
		T o1 = heap.get(i);
		T o2 = heap.get(j);
		heap.set(i, o2);
		heap.set(j, o1);
		indexMap.put(o2, i);
		indexMap.put(o1, j);
	}

}
```

